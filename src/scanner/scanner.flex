package scanner;

import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import parser.ParserSym;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import programa.GestorErrores;

%%
%public              
%class Scanner       
%unicode
%cup
%line
%column

%{
  /** The CUP symbol factory, typically shared with parser. */
  private ComplexSymbolFactory symbolFactory = new ComplexSymbolFactory();
  private GestorErrores gestorErrores;

  /** Initialize scanner with input stream and a shared symbol factory. */
  public Scanner(java.io.Reader in, ComplexSymbolFactory sf, GestorErrores gestorErr) {
    this(in);
    this.symbolFactory = sf;
    this.gestorErrores = gestorErr;
  }

  /**
   * Construccion de un simbolo sin atributo asociado
   *
   * @param code     identifier of the lexical token (i.e., ParserSym.<TOKEN>)
   * @effects        constructs new ComplexSymbol via this.symbolFactory
   * @return         a fresh symbol storing the above-desribed information
   */
  private Symbol symbol(int code) {
    // Calculate symbol location
    int yylen = yylength(); // returns the length of the matched input text region = yytext().length()
    Location left = new Location(yyline + 1, yycolumn + 1);
    Location right = new Location(yyline + 1, yycolumn + (yylen+1));

    return this.symbolFactory.newSymbol(ParserSym.terminalNames[code], code, left, right);
  }

  /**
   * Construccion de un simbolo con atributo asociado
   *
   * @param code     identifier of the lexical token (i.e., ParserSym.<TOKEN>)
   * @param value    user-controlled datum to associate with this symbol
   * @effects        constructs new ComplexSymbol via this.symbolFactory
   * @return         a fresh symbol storing the above-desribed information
   */
  private Symbol symbol(int code, Object value) {
    // Calculate symbol location
    int yylen = yylength();
    Location left = new Location(yyline + 1, yycolumn + 1);
    Location right = new Location(yyline + 1, yycolumn + (yylen+1));

    return this.symbolFactory.newSymbol(ParserSym.terminalNames[code], code, left, right,value);
  }

  /**
   * Convierte el simbolo generado a String
   *
   * @param symbol   symbol instance generated by this scanner
   * @return         string representation of the symbol
   */
   public String symbolToString(Symbol s) {
     // All symbols generated by this class are ComplexSymbol instances
     ComplexSymbol cs = (ComplexSymbol)s; 
     if (cs.sym == ParserSym.IDENTIFIER) {
       return "ID(" + (String)cs.value + ")";
     } else if (cs.sym == ParserSym.INT_LITERAL) {
       return cs.getName() + "(" +(String)cs.value + ")";
     } else if (cs.sym == ParserSym.error) {
       return "<UNEXPECTED(" + (String)cs.value + ")>";
     } else {
       return cs.getName();
     }
   }
    
    public void imprimirTokens(String nombreArchivo){
        String nombArch = "src/programa/" + nombreArchivo + ".txt";
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(nombArch))){
            Symbol t = next_token();
            while (t.sym != ParserSym.EOF) {
                writer.write(symbolToString(t) + "\n");
                t = next_token();
            }
        } catch (IOException ex) {
                System.err.println("Error al escribir en el archivo: " + ex.getMessage());
            }   
    }

    private void report_error(int linea,int columna, String mensaje) {
        gestorErrores.agregarError(linea,columna, mensaje); // Suponiendo que tienes una manera de obtener la l√≠nea actual
    }

%}

// Declaraciones
letra       = [a-zA-Z]
digito      = [0-9]
id          = {letra}({letra}|{digito}|_)*

LineTerminator = \r|\n|\r\n
InputCharacter = [^\r\n]
WhiteSpace     = {LineTerminator} | [ \t\f]

/* comments */
Comment = {TraditionalComment} | {EndOfLineComment} | {DocumentationComment}

TraditionalComment   = "/*" [^*] ~"*/" | "/*" "*"+ "/"
// Comment can be the last line of the file, without line terminator.
EndOfLineComment     = "//" {InputCharacter}* {LineTerminator}?
DocumentationComment = "/**" {CommentContent} "*"+ "/"
CommentContent       = ( [^*] | \*+ [^/*] )*

%%

"main"                  { return symbol(ParserSym.MAIN); }
"if"                    { return symbol(ParserSym.IF); }
"else"			{ return symbol(ParserSym.ELSE); }
"while"                 { return symbol(ParserSym.WHILE); }
"for"                   { return symbol(ParserSym.FOR); }
"read"                  { return symbol(ParserSym.READ); }
"write"                 { return symbol(ParserSym.WRITE); }
"int"			{ return symbol(ParserSym.INT); }
"boolean"		{ return symbol(ParserSym.BOOLEAN); }
"const"                 { return symbol(ParserSym.CONST); }
"return"		{ return symbol(ParserSym.RETURN); }
"tupla"                 { return symbol(ParserSym.TUPLA); }
"get"                   { return symbol(ParserSym.GET); }
"def"                   { return symbol(ParserSym.DEF); }
"true"                  { return symbol(ParserSym.TRUE);}        
"false"                 { return symbol(ParserSym.FALSE);}

/* Operadores */
"||"                    { return symbol(ParserSym.OR); }
"&&"                    { return symbol(ParserSym.AND); }
"=="                    { return symbol(ParserSym.EQ); }
"!="                    { return symbol(ParserSym.NEQ); }
"<"                     { return symbol(ParserSym.LT); }
">"                     { return symbol(ParserSym.GT); }
"+"                     { return symbol(ParserSym.ADD); }
"-"                     { return symbol(ParserSym.SUB); }
"*"                     { return symbol(ParserSym.MUL); }
"="                     { return symbol(ParserSym.ASSIGN); }
  
/* Delimitadores */
"("                     { return symbol(ParserSym.LPAREN); }
")"                     { return symbol(ParserSym.RPAREN); }
"{"                     { return symbol(ParserSym.LLLAVE); }
"}"                     { return symbol(ParserSym.RLLAVE); }
","                     { return symbol(ParserSym.COMA); }
";"                     { return symbol(ParserSym.PUNTOYCOMA); }
"!"                     { return symbol(ParserSym.NOT); }
"."                     { return symbol(ParserSym.PUNTO); }

/* Identificadores y Literales */
{id}                    { return symbol(ParserSym.IDENTIFIER, yytext()); }
{digito}+               { return symbol(ParserSym.INT_LITERAL, yytext()); }

// Espacio en blanco
{WhiteSpace}            { /* Ignorar los espacios */}
{Comment}               { /* ignore */ }

[^]                      {  
                            String msg = "no se reconoce este Token: '" + yytext() + "'";
                            report_error(yyline + 1, yycolumn + 1,msg);
                            return symbol(ParserSym.error);  }

<<EOF>>                 { return symbol(ParserSym.EOF); }
